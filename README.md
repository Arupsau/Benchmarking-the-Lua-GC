# Benchmarking-the-Lua-GC
<h2>Introduction :</h2>
Lua is a lightweight, high-level scripting language known for its simple syntax and
efficient memory management. Understanding Lua’s garbage collection (GC) is crucial
for optimizing Lua applications and ensuring efficient memory usage. This report
examines Lua’s GC mechanisms, focusing on three configurations: Full GC,
Incremental GC, and Generational GC.
<h2>C Files for Different GC Configurations:</h2>
Three C programs were written to test Lua’s GC under different configurations. Each
program initializes Lua, runs a testbench script, and measures the time taken for GC
operations.
<h2>Profiling with Callgrind:</h2>
The executables (fullgc.c, incrementalgc.c, and generationalgc.c) were profiled using
Callgrind (part of Valgrind) to analyze their performance. The generated profiling data
analyze using tools like kcachegrind to generate call graphs and further study the GC
behavior.

</p>
<h3> Call Graph of FULL-GC </h3>
<br>
<p align="center">
<img src = "https://github.com/Arupsau/Benchmarking-the-Lua-GC/blob/main/Images/fullgc_compact.png">
</p>
</p>
<h3> Call Graph of Generational-GC </h3>
<br>
<p align="center">
<img src = "https://github.com/Arupsau/Benchmarking-the-Lua-GC/blob/main/Images/generationalgc_compact.png">
</p>
</p>
<h3> Call Graph of Incremental-GC </h3>
<br>
<p align="center">
<img src = "https://github.com/Arupsau/Benchmarking-the-Lua-GC/blob/main/Images/incrementalgc_compact.png">
</p>
<h2>Analysis of GC Mechanisms:</h2>
The call graphs generated by kcachegrind provided insights into the inner workings of
Lua's garbage collector.

*Full GC:
In Full GC mode, Lua's garbage collector goes through all allocated memory, marking
reachable objects and collecting all others in one complete cycle. The source code
shows that this process involves traversing the entire memory space, which can cause
significant pauses in the program.

*Incremental GC:
Incremental GC operates in phases, breaking down the GC process into smaller parts.
The Lua source code reveals that the GC state machine advances in small steps,
allowing the program to continue execution in between. This reduces the GC's impact
on application performance.

*Generational GC:
Generational GC divides objects into young and old generations. The source code
indicates that Lua collects the young generation more frequently, based on the
assumption that most objects die young. This method reduces the overhead of
repeatedly scanning long-lived objects.

Lua's garbage collection system is highly flexible, with different modes offering
trade-offs between collection frequency and pause times.

● Full GC is the most straightforward but can lead to significant pauses, making it
less suitable for performance-critical applications.

● Incremental GC provides a balance, reducing pause times at the cost of slightly
increased total GC overhead.

● Generational GC is the most advanced, offering the best performance by
focusing GC efforts on younger objects, which are more likely to be discarded
quickly.
